Frontend files for Community Detail & PostItem API integration - Collected on Mon Jun  2 11:31:31 UTC 2025
==================================================================================

--- START OF FILE: src/components/communities/CommunityDetailScreen.tsx ---

import React, { useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import BottomNavigation from '@/components/layout/BottomNavigation';
import { communities, getPopulatedPosts, userFollowedCommunityIds } from '@/data/communitySampleData';
import PostListItem from './PostListItem';
import CreatePostScreen from './CreatePostScreen';
import { ChevronLeft } from 'lucide-react';

const CommunityDetailScreen = () => {
  const { communityId } = useParams<{ communityId: string }>();
  const navigate = useNavigate();
  
  const community = communities.find(c => c.id === communityId);
  const posts = getPopulatedPosts(communityId || '');

  // State for join/leave functionality
  const [isJoined, setIsJoined] = useState(
    userFollowedCommunityIds.includes(communityId || '')
  );
  const [memberCount, setMemberCount] = useState(community?.memberCount || 0);

  // State for create post modal
  const [isCreatePostOpen, setIsCreatePostOpen] = useState(false);

  if (!community) {
    return <div>Community not found</div>;
  }

  const handleCreatePost = () => {
    setIsCreatePostOpen(true);
  };

  const handleJoinLeave = () => {
    if (isJoined) {
      // Leave community
      setIsJoined(false);
      setMemberCount(prev => prev - 1);
      alert(`You've left ${community.name}!`);
    } else {
      // Join community
      setIsJoined(true);
      setMemberCount(prev => prev + 1);
      alert(`You've joined ${community.name}!`);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 pb-20">
      {/* Header */}
      <div className="bg-white dark:bg-gray-800 shadow-sm px-4 py-4">
        <div className="flex items-center space-x-3">
          <Button 
            variant="ghost" 
            size="icon"
            onClick={() => navigate('/communities')}
          >
            <ChevronLeft className="h-5 w-5" />
          </Button>
          <div className="flex-1">
            <h1 className="text-xl font-bold text-gray-900 dark:text-white">
              {community.name}
            </h1>
          </div>
          <Button 
            size="sm" 
            className="bg-unicampus-red hover:bg-unicampus-red-dark text-white"
            onClick={handleCreatePost}
          >
            Create Post
          </Button>
        </div>
      </div>

      <div className="space-y-4">
        {/* Community Banner */}
        <Card className="mx-4 mt-4">
          <CardContent className="p-0">
            {community.bannerImage && (
              <div className="h-40 w-full overflow-hidden rounded-t-lg">
                <img 
                  src={community.bannerImage} 
                  alt={community.name}
                  className="w-full h-full object-cover"
                />
              </div>
            )}
            <div className="p-4">
              <div className="flex items-start space-x-4">
                <div className="text-4xl">{community.icon}</div>
                <div className="flex-1">
                  <h2 className="font-bold text-xl text-gray-900 dark:text-white">
                    {community.name}
                  </h2>
                  <p className="text-gray-600 dark:text-gray-400 mt-1">
                    {community.description}
                  </p>
                  <div className="flex items-center justify-between mt-3">
                    <Badge variant="secondary">
                      {memberCount.toLocaleString()} members
                    </Badge>
                    <Button
                      variant={isJoined ? "secondary" : "outline"}
                      size="sm"
                      onClick={handleJoinLeave}
                      className={
                        isJoined 
                          ? "bg-gray-100 dark:bg-gray-700 text-unicampus-red hover:bg-gray-200 dark:hover:bg-gray-600" 
                          : "border-unicampus-red text-unicampus-red hover:bg-unicampus-red hover:text-white"
                      }
                    >
                      {isJoined ? 'Joined' : 'Join'}
                    </Button>
                  </div>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Posts */}
        <div className="px-4 space-y-3">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Posts</h3>
          {posts.length > 0 ? (
            posts.map((post, index) => (
              <PostListItem 
                key={post.id} 
                post={post} 
                index={index}
                onClick={() => navigate(`/communities/${communityId}/posts/${post.id}`)}
              />
            ))
          ) : (
            <Card>
              <CardContent className="p-8 text-center">
                <p className="text-gray-500 dark:text-gray-400">
                  No posts yet. Be the first to start a discussion!
                </p>
              </CardContent>
            </Card>
          )}
        </div>
      </div>

      {/* Create Post Modal */}
      <CreatePostScreen 
        isOpen={isCreatePostOpen} 
        onClose={() => setIsCreatePostOpen(false)}
        preselectedCommunityId={communityId}
      />

      <BottomNavigation />
    </div>
  );
};

export default CommunityDetailScreen;

--- END OF FILE: src/components/communities/CommunityDetailScreen.tsx ---

--------------------------------------------------------------

--- START OF FILE: src/components/communities/PostListItem.tsx ---

import React, { useState } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Badge } from '@/components/ui/badge';
import { ChevronUp, ChevronDown, MessageSquare } from 'lucide-react';
import { Post, User, Community } from '@/data/communitySampleData';

interface PostListItemProps {
  post: Post & { author: User; community?: Community };
  index: number;
  showCommunity?: boolean;
  onClick: () => void;
}

const PostListItem: React.FC<PostListItemProps> = ({ post, index, showCommunity = false, onClick }) => {
  const [userVote, setUserVote] = useState<'up' | 'down' | null>(post.userVote || null);
  const [upvotes, setUpvotes] = useState(post.upvotes);

  const handleVote = (voteType: 'up' | 'down', e: React.MouseEvent) => {
    e.stopPropagation();
    
    if (userVote === voteType) {
      // Remove vote
      setUserVote(null);
      setUpvotes(prev => voteType === 'up' ? prev - 1 : prev + 1);
    } else {
      // Change or add vote
      const change = voteType === 'up' ? 1 : -1;
      const currentChange = userVote === 'up' ? -1 : userVote === 'down' ? 1 : 0;
      setUpvotes(prev => prev + change + currentChange);
      setUserVote(voteType);
    }
  };

  const formatTimeAgo = (date: Date) => {
    const now = new Date();
    const diffInHours = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60));
    
    if (diffInHours < 1) return 'Just now';
    if (diffInHours < 24) return `${diffInHours}h ago`;
    return `${Math.floor(diffInHours / 24)}d ago`;
  };

  return (
    <Card 
      className="animate-slide-up cursor-pointer hover:shadow-lg transition-all"
      style={{ animationDelay: `${index * 0.1}s` }}
      onClick={onClick}
    >
      <CardContent className="p-4">
        {/* Community Badge (if showing in feed) */}
        {showCommunity && post.community && (
          <div className="mb-2">
            <Badge variant="outline" className="text-xs border-unicampus-red text-unicampus-red">
              {post.community.icon} {post.community.name}
            </Badge>
          </div>
        )}

        {/* Author Info */}
        <div className="flex items-center space-x-3 mb-3">
          <Avatar className="h-8 w-8">
            <AvatarImage src={post.author.avatarUrl} />
            <AvatarFallback>
              {post.author.name.split(' ').map(n => n[0]).join('')}
            </AvatarFallback>
          </Avatar>
          <div className="flex-1">
            <p className="text-sm font-medium text-gray-900 dark:text-white">
              {post.author.name}
            </p>
            <p className="text-xs text-gray-500 dark:text-gray-400">
              {formatTimeAgo(post.timestamp)}
            </p>
          </div>
        </div>

        {/* Post Content */}
        <div className="mb-3">
          <h3 className="font-semibold text-gray-900 dark:text-white mb-2">
            {post.title}
          </h3>
          <p className="text-sm text-gray-600 dark:text-gray-400 line-clamp-3">
            {post.contentPreview}
          </p>
        </div>

        {/* Post Image */}
        {post.image && (
          <div className="mb-3 rounded-lg overflow-hidden">
            <img 
              src={post.image} 
              alt="Post content"
              className="w-full h-48 object-cover"
            />
          </div>
        )}

        {/* Actions */}
        <div className="flex items-center space-x-4">
          <div className="flex items-center space-x-1">
            <Button
              variant="ghost"
              size="sm"
              className={`p-1 h-8 w-8 ${
                userVote === 'up' 
                  ? 'text-unicampus-red bg-unicampus-red/10' 
                  : 'text-gray-500 dark:text-gray-400'
              }`}
              onClick={(e) => handleVote('up', e)}
            >
              <ChevronUp className="h-4 w-4" />
            </Button>
            <span className="text-sm font-medium text-gray-700 dark:text-gray-300 min-w-[2rem] text-center">
              {upvotes}
            </span>
            <Button
              variant="ghost"
              size="sm"
              className={`p-1 h-8 w-8 ${
                userVote === 'down' 
                  ? 'text-unicampus-red bg-unicampus-red/10' 
                  : 'text-gray-500 dark:text-gray-400'
              }`}
              onClick={(e) => handleVote('down', e)}
            >
              <ChevronDown className="h-4 w-4" />
            </Button>
          </div>
          
          <Button
            variant="ghost"
            size="sm"
            className="flex items-center space-x-1 text-gray-500 dark:text-gray-400 hover:text-unicampus-red"
            onClick={onClick}
          >
            <MessageSquare className="h-4 w-4" />
            <span className="text-sm">{post.commentsCount}</span>
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};

export default PostListItem;

--- END OF FILE: src/components/communities/PostListItem.tsx ---

--------------------------------------------------------------

--- START OF FILE (Optional): src/components/communities/CreatePostScreen.tsx ---
// src/components/communities/CreatePostScreen.tsx
import React, { useState, useEffect } from 'react';
import { X, Camera } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { 
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
// Remove mock data import: import { communities, userFollowedCommunityIds } from '@/data/communitySampleData';
import apiClient, { PaginatedResponse } from '@/lib/apiClient'; // Import apiClient
import { toast } from '@/hooks/use-toast'; // Assuming you use a toast hook
import { useAuth } from '@/contexts/AuthContext'; // To ensure user is authenticated

// Define Community type based on your API
interface Community {
  id: string; // or _id
  name: string;
  slug?: string;
  icon?: string; // Or however you represent icons
  // Add other fields like description, member_count etc.
  is_member?: boolean; // If your API provides this
}

interface CreatePostScreenProps {
  isOpen: boolean;
  onClose: () => void;
  preselectedCommunityId?: string;
  onPostCreated?: (newPost: any) => void; // Callback after successful post creation
}

// Define Post type (or import if defined elsewhere)
interface PostData {
    title: string;
    content_type: 'text' | 'image' | 'link'; // Match your API
    content_text?: string;
    image_url?: string; // If you handle image uploads separately and get a URL
    link_url?: string;
    tags?: string[];
}

const CreatePostScreen = ({ 
    isOpen, 
    onClose, 
    preselectedCommunityId,
    onPostCreated 
}: CreatePostScreenProps) => {
  const { isAuthenticated } = useAuth();
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [selectedCommunity, setSelectedCommunity] = useState(preselectedCommunityId || '');
  // const [image, setImage] = useState<string | null>(null); // Image handling needs more thought (upload first or base64?)
  const [imageFile, setImageFile] = useState<File | null>(null);


  const [availableCommunities, setAvailableCommunities] = useState<Community[]>([]);
  const [isLoadingCommunities, setIsLoadingCommunities] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Fetch communities when component might become visible or when needed
  useEffect(() => {
    if (isOpen && isAuthenticated && !preselectedCommunityId) { // Only fetch if selector is needed
      const fetchCommunities = async () => {
        setIsLoadingCommunities(true);
        try {
          // Assuming your list communities endpoint is paginated but we fetch a reasonable limit for a dropdown
          const response = await apiClient<PaginatedResponse<Community>>('/communities?limit=100');
          if (response.status === 'success' && response.data) {
            // TODO: Potentially sort them by userFollowedCommunityIds if API doesn't do it
            setAvailableCommunities(response.data);
          }
        } catch (error) {
          console.error("Failed to fetch communities:", error);
          toast({ title: "Error", description: "Could not load communities.", variant: "destructive" });
        } finally {
          setIsLoadingCommunities(false);
        }
      };
      fetchCommunities();
    }
  }, [isOpen, isAuthenticated, preselectedCommunityId]);

  useEffect(() => {
    if (preselectedCommunityId) {
      setSelectedCommunity(preselectedCommunityId);
      // If you want to show the preselected community name, you might need to fetch its details
      // or ensure it's part of `availableCommunities` if that list is always fetched.
    } else {
        setSelectedCommunity(''); // Clear if no preselection
    }
  }, [preselectedCommunityId, isOpen]); // Reset if dialog reopens or preselection changes


  const preselectedCommunityDetails = availableCommunities.find(c => c.id === preselectedCommunityId) || 
                                    (preselectedCommunityId ? {id: preselectedCommunityId, name: "Selected Community"} : null) ; // Fallback name

  const handleSubmit = async () => {
    if (!title.trim() || !content.trim() || !selectedCommunity) {
      toast({ title: "Validation Error", description: "Please fill in all required fields.", variant: "destructive"});
      return;
    }
    if (!isAuthenticated) {
        toast({ title: "Authentication Error", description: "Please log in to create a post.", variant: "destructive"});
        return;
    }

    setIsSubmitting(true);

    const postData: PostData = {
      title: title.trim(),
      content_type: "text", // Defaulting to text, can be enhanced for image/link
      content_text: content.trim(),
      // tags: ["some", "tags"] // Add tag input if needed
    };

    // TODO: Image Upload Logic
    // If imageFile exists, you'd typically upload it first to get a URL, then include that URL in postData.
    // This requires a separate endpoint for image uploads (e.g., to your Node.js service).
    // For now, we're not including image_url.

    try {
      const response = await apiClient<any>( // Define a proper type for the created post response
        `/communities/${selectedCommunity}/posts`,
        {
          method: 'POST',
          data: postData,
        }
      );
      
      // Assuming API returns the created post object directly in response or response.data
      const createdPost = response.data?.post || response.data || response; 
      
      toast({ title: "Success", description: `Post created in ${preselectedCommunityDetails?.name || 'selected community'}!` });
      
      if (onPostCreated && createdPost) {
        onPostCreated(createdPost);
      }

      // Reset form
      setTitle('');
      setContent('');
      setImageFile(null);
      if (!preselectedCommunityId) { // Don't reset if it was preselected
        setSelectedCommunity('');
      }
      onClose();
    } catch (error: any) {
      console.error("Failed to create post:", error);
      toast({ 
        title: "Error Creating Post", 
        description: error.message || "An unexpected error occurred.", 
        variant: "destructive" 
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleImageInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files && event.target.files[0]) {
      setImageFile(event.target.files[0]);
      // Optionally show a preview
    }
  };

  const isFormValid = title.trim() && content.trim() && selectedCommunity;

  return (
    <Dialog open={isOpen} onOpenChange={(open) => { if (!open) onClose(); }}>
      <DialogContent className="sm:max-w-[425px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <div className="flex items-center justify-between">
            <DialogTitle className="text-lg font-semibold text-gray-900 dark:text-white">
              {preselectedCommunityId ? `New Post in ${preselectedCommunityDetails?.name}` : 'Create New Post'}
            </DialogTitle>
            <Button
              variant="ghost"
              size="icon"
              onClick={onClose}
              className="h-6 w-6 p-0 hover:bg-gray-100 dark:hover:bg-gray-800"
            >
              <X className="h-4 w-4" />
            </Button>
          </div>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {/* Community Selector */}
          {!preselectedCommunityId && (
            <div className="space-y-2">
              <Label htmlFor="community" className="text-sm font-medium text-gray-700 dark:text-gray-300">
                Community *
              </Label>
              <Select value={selectedCommunity} onValueChange={setSelectedCommunity} disabled={isLoadingCommunities}>
                <SelectTrigger className="w-full">
                  <SelectValue placeholder={isLoadingCommunities ? "Loading communities..." : "Select a community"} />
                </SelectTrigger>
                <SelectContent>
                  {availableCommunities.map((community) => (
                    <SelectItem key={community.id} value={community.id}>
                      <div className="flex items-center space-x-2">
                        {community.icon && <span className="text-lg">{community.icon}</span>}
                        <span>{community.name}</span>
                      </div>
                    </SelectItem>
                  ))}
                   {availableCommunities.length === 0 && !isLoadingCommunities && (
                     <div className="px-2 py-1.5 text-sm text-gray-500 dark:text-gray-400">No communities found or could not load.</div>
                   )}
                </SelectContent>
              </Select>
            </div>
          )}

          {/* Show selected community when preselected */}
          {preselectedCommunityId && preselectedCommunityDetails && (
            <div className="space-y-2">
              <Label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                Posting to
              </Label>
              <div className="flex items-center space-x-2 p-3 bg-gray-50 dark:bg-gray-800 rounded-md">
                {preselectedCommunityDetails.icon && <span className="text-lg">{preselectedCommunityDetails.icon}</span>}
                <span className="font-medium text-gray-900 dark:text-white">{preselectedCommunityDetails.name}</span>
              </div>
            </div>
          )}

          {/* Title Input */}
          <div className="space-y-2">
            <Label htmlFor="title" className="text-sm font-medium text-gray-700 dark:text-gray-300">
              Title *
            </Label>
            <Input
              id="title"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder="Enter post title..."
              className="w-full"
            />
          </div>

          {/* Content Input */}
          <div className="space-y-2">
            <Label htmlFor="content" className="text-sm font-medium text-gray-700 dark:text-gray-300">
              Content *
            </Label>
            <Textarea
              id="content"
              value={content}
              onChange={(e) => setContent(e.target.value)}
              placeholder="What's on your mind?"
              className="w-full min-h-[120px] resize-none"
              rows={5}
            />
          </div>

          {/* Add Image Input */}
          <div className="space-y-2">
             <Label htmlFor="imageFile" className="text-sm font-medium text-gray-700 dark:text-gray-300">
              Attach Image (Optional)
            </Label>
            <Input
              id="imageFile"
              type="file"
              accept="image/*"
              onChange={handleImageInputChange}
              className="w-full file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-unicampus-red/10 file:text-unicampus-red hover:file:bg-unicampus-red/20"
            />
            {imageFile && <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">Selected: {imageFile.name}</p>}
          </div>


          {/* Submit Button */}
          <div className="flex justify-end space-x-2 pt-4">
            <Button
              variant="outline"
              onClick={onClose}
              className="px-6"
              disabled={isSubmitting}
            >
              Cancel
            </Button>
            <Button
              onClick={handleSubmit}
              disabled={!isFormValid || isSubmitting}
              className="px-6 bg-unicampus-red hover:bg-unicampus-red-dark text-white disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isSubmitting ? "Posting..." : "Post"}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default CreatePostScreen;
--- END OF FILE (Optional): src/components/communities/CreatePostScreen.tsx ---

--------------------------------------------------------------

--- START OF CORE FILE: src/contexts/AuthContext.tsx ---
// src/contexts/AuthContext.tsx
import React, { createContext, useContext, useState, ReactNode, useEffect } from 'react';
import apiClient from '../lib/apiClient'; // Import the API client

// Updated User interface based on your /auth/login/student response
interface User {
  id: string;         // User's MongoDB ObjectId
  usn: string;
  name: string;
  email: string;       // e.g., usn@unicampus.app
  role: 'student' | 'admin'; // Assuming admin role also exists
  collegeProfile?: {
    officialName?: string;
    department?: string;
    semester?: number;
    section?: string;
    usn?: string; // Can be redundant but might be from a different source
    // Add other fields as per your API
  };
  mostRecentCGPA?: number | null;
  avatar?: string | null;
  // Add fields from /users/me if different/more comprehensive
  academicSummaries?: Array<{ code: string; name: string; cieTotal: number | null; attendancePercentage: number | null }>;
  examHistory?: Array<{ semesterName: string; creditsRegistered: number; creditsEarned: number; sgpa: number | null; cgpa: number | null }>;
  collegeDataLastUpdated?: string; // ISO datetime
  createdAt?: string; // ISO datetime
  updatedAt?: string; // ISO datetime
}

// API Response structure for login
interface LoginApiResponse {
  status: string;
  accessToken: string;
  refreshToken: string;
  data: {
    user: User;
  };
}

// API Response structure for /users/me
interface UserProfileApiResponse {
    status: string;
    data: {
        user: User;
    };
}

// API Response for token refresh
interface RefreshTokenApiResponse {
    status: string;
    accessToken: string;
}


interface AuthContextType {
  user: User | null;
  accessToken: string | null; // Store accessToken
  isLoading: boolean; // For initial load and login/logout processes
  isAuthenticated: boolean;
  login: (usn: string, dob_dd: string, dob_mm: string, dob_yyyy: string) => Promise<void>; // Update params
  logout: () => Promise<void>;
  fetchUserProfile: () => Promise<void>; // To load user on app start or refresh
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [accessToken, setAccessToken] = useState<string | null>(localStorage.getItem('accessToken'));
  const [refreshToken, setRefreshToken] = useState<string | null>(localStorage.getItem('refreshToken'));
  const [isLoading, setIsLoading] = useState(true); // True initially to load user

  const isAuthenticated = !!accessToken && !!user; // User must also be loaded

  useEffect(() => {
    const loadUserFromToken = async () => {
      if (accessToken) {
        try {
          await fetchUserProfile(); // Try to fetch user profile if token exists
        } catch (error: any) {
          console.error("Failed to load user with existing token:", error);
          if (error.httpStatus === 401) { // If token is invalid/expired
            await attemptRefreshTokenAndRetry(fetchUserProfile);
          } else {
            // For other errors, or if refresh fails, clear auth data
            clearAuthData();
          }
        }
      }
      setIsLoading(false);
    };
    loadUserFromToken();
  }, []); // Empty dependency array: run once on mount

  const storeAuthData = (accessTok: string, refreshTok: string, userData?: User) => {
    localStorage.setItem('accessToken', accessTok);
    localStorage.setItem('refreshToken', refreshTok);
    setAccessToken(accessTok);
    setRefreshToken(refreshTok);
    if (userData) {
        setUser(userData);
    }
  };

  const clearAuthData = () => {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
    setAccessToken(null);
    setRefreshToken(null);
    setUser(null);
  };

  const login = async (usn: string, dob_dd: string, dob_mm: string, dob_yyyy: string): Promise<void> => {
    setIsLoading(true);
    try {
      const response = await apiClient<LoginApiResponse>('/auth/login/student', {
        method: 'POST',
        data: { usn, dob_dd, dob_mm, dob_yyyy }, // Match your API request body
        isPublic: true, // Login doesn't require a token
      });

      if (response.status === 'success' && response.accessToken && response.refreshToken && response.data.user) {
        storeAuthData(response.accessToken, response.refreshToken, response.data.user);
      } else {
        // If API returns success but missing data, treat as error
        throw new Error(response.status || 'Login failed: Invalid response from server.');
      }
    } catch (error: any) {
      clearAuthData(); // Ensure tokens are cleared on login failure
      console.error("Login error:", error);
      throw error; // Re-throw to be caught by LoginScreen
    } finally {
      setIsLoading(false);
    }
  };

  const logout = async () => {
    setIsLoading(true);
    // Call backend logout if it exists and does something meaningful (e.g., invalidates refresh token)
    try {
        if (accessToken) { // Only call if there's a token to invalidate
            await apiClient('/auth/logout', { method: 'POST' });
        }
    } catch (error) {
        console.warn("Backend logout call failed or not critical, clearing client-side tokens:", error);
    } finally {
        clearAuthData();
        setIsLoading(false);
        // Optionally navigate to login or home page after logout
        // navigate('/login'); // if using react-router
    }
  };

  const fetchUserProfile = async (): Promise<void> => {
    if (!localStorage.getItem('accessToken')) { // Use localStorage directly here as state might not be updated yet
      // setIsLoading(false); // Ensure loading state is managed
      return; // No token, no user to fetch
    }
    // setIsLoading(true); // Set loading true when fetching
    try {
      const response = await apiClient<UserProfileApiResponse>('/users/me', { method: 'GET' });
      if (response.status === 'success' && response.data.user) {
        setUser(response.data.user);
      } else {
        throw new Error('Failed to fetch user profile: Invalid response.');
      }
    } catch (error: any) {
      console.error("Fetch user profile error:", error);
      if (error.httpStatus === 401) { // Token might be expired
        // Attempt to refresh token, then retry fetching profile
        await attemptRefreshTokenAndRetry(fetchUserProfile);
      } else {
        // For other errors, or if refresh fails, clear auth data
        clearAuthData();
      }
      throw error; // Re-throw for components or initial load to handle
    }
    // finally { setIsLoading(false); } // Manage loading state appropriately
  };

  const attemptRefreshTokenAndRetry = async (retryCallback: () => Promise<void>) => {
    const currentRefreshToken = localStorage.getItem('refreshToken');
    if (!currentRefreshToken) {
      console.log("No refresh token available. Logging out.");
      clearAuthData();
      return;
    }

    try {
      console.log("Attempting to refresh token...");
      const refreshResponse = await apiClient<RefreshTokenApiResponse>('/auth/refresh-token', {
        method: 'POST',
        isRefreshTokenRequest: true, // Use refresh token for Authorization header
        isPublic: false, // Although it uses a token, it's a specific auth flow
      });

      if (refreshResponse.status === 'success' && refreshResponse.accessToken) {
        console.log("Token refreshed successfully.");
        // Store only the new access token. Refresh token might also be rotated by backend.
        // For simplicity, we assume refresh token remains valid or backend doesn't rotate it often.
        // If backend sends new refresh token, update it here.
        storeAuthData(refreshResponse.accessToken, currentRefreshToken); // Re-use old refresh token for now
        await retryCallback(); // Retry the original failed request (e.g., fetchUserProfile)
      } else {
        console.error("Token refresh failed with success status but no new token.");
        clearAuthData(); // If refresh fails, logout
      }
    } catch (refreshError) {
      console.error("Token refresh API call failed:", refreshError);
      clearAuthData(); // If refresh fails, logout
    }
  };


  return (
    <AuthContext.Provider value={{
      user,
      accessToken, // Expose accessToken if needed by other parts of app directly (though apiClient handles it)
      isLoading,
      login,
      logout,
      isAuthenticated,
      fetchUserProfile
    }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
--- END OF CORE FILE: src/contexts/AuthContext.tsx ---

--------------------------------------------------------------

--- START OF CORE FILE: src/lib/apiClient.ts ---
// src/lib/apiClient.ts
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001/api/v1';

// Helper to get token from localStorage (AuthContext will manage this)
const getAuthToken = (): string | null => {
  return localStorage.getItem('accessToken');
};

interface ApiClientOptions extends RequestInit {
  data?: any;
  isPublic?: boolean; // To bypass auth header for public routes
  isRefreshTokenRequest?: boolean; // Special flag for refresh token request
}

// Define a generic error structure your API might return
interface ApiError {
  status: string; // "fail" or "error"
  message: string;
  // Add other potential error fields
}

export interface PaginatedResponse<T> {
  status: string;
  results?: number; // If your API returns total results
  data: T[]; // Assuming data is always an array for paginated lists
  // Add other pagination fields if your API returns them (e.g., totalPages, currentPage)
}


async function apiClient<T>(
  endpoint: string,
  { data, headers: customHeaders, isPublic = false, isRefreshTokenRequest = false, ...customConfig }: ApiClientOptions = {}
): Promise<T> {
  const config: RequestInit = {
    method: data ? 'POST' : 'GET', // Default to POST if data is provided
    ...customConfig,
    headers: {
      ...(data && !(data instanceof FormData) && { 'Content-Type': 'application/json' }), // Don't set for FormData
      ...customHeaders,
    },
  };

  if (!isPublic) {
    const token = isRefreshTokenRequest ? localStorage.getItem('refreshToken') : getAuthToken();
    if (token) {
      config.headers = {
        ...config.headers,
        Authorization: `Bearer ${token}`,
      };
    } else if (endpoint !== '/auth/login/student' && !endpoint.startsWith('/app/info')) {
      // For non-public routes (excluding login and app info), if no token, it's an issue.
      // AuthContext will handle redirect or state change.
      console.warn(`No auth token found for protected route: ${endpoint}`);
      // Throw an error or let AuthContext handle this by checking isAuthenticated
      return Promise.reject({ status: 401, message: 'Authentication token is missing.' });
    }
  }

  if (data) {
    if (data instanceof FormData) {
      config.body = data; // FormData handles its own content type
    } else {
      config.body = JSON.stringify(data);
    }
  }

  const response = await fetch(`${API_BASE_URL}${endpoint}`, config);

  if (!response.ok) {
    // Attempt to parse error JSON, otherwise use statusText
    let errorData: ApiError | { message: string };
    try {
      errorData = await response.json();
      if (typeof errorData !== 'object' || !('message' in errorData)) {
        // If the parsed JSON doesn't have a message, create one
        errorData = { message: response.statusText || 'Unknown error occurred' };
      }
    } catch (e) {
      errorData = { message: response.statusText || 'Failed to parse error response.' };
    }
    // Add status code to the rejected error object
    return Promise.reject({ httpStatus: response.status, ...errorData });
  }

  if (response.status === 204 || response.headers.get('Content-Length') === '0') {
    // For 204 No Content or empty responses, resolve with a success indicator or undefined.
    // Depending on T, you might want to cast or return a specific success object.
    return { status: 'success', message: 'Operation successful' } as unknown as T;
  }

  return response.json() as Promise<T>;
}

export default apiClient;
--- END OF CORE FILE: src/lib/apiClient.ts ---

--------------------------------------------------------------

--- START OF CORE FILE: src/App.tsx ---
// src/App.tsx
import React from 'react'; // Ensure React is imported if using React.ReactNode etc.
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { Routes, Route, Navigate } from "react-router-dom";
import { ThemeProvider } from "@/contexts/ThemeContext";
import { useAuth } from "@/contexts/AuthContext";
import Index from "./pages/Index";
import NotFound from "./pages/NotFound";
import LoginScreen from "@/components/auth/LoginScreen";
import Dashboard from "@/components/dashboard/Dashboard";
import ResultsScreen from "@/components/results/ResultsScreen";
import CommunitiesScreen from "@/components/communities/CommunitiesScreen";
import CommunityDetailScreen from "@/components/communities/CommunityDetailScreen";
import AttendanceScreen from "@/components/attendance/AttendanceScreen";
import ResourcesScreen from "@/components/resources/ResourcesScreen";
import SettingsScreen from "@/components/settings/SettingsScreen";
import CreateResourceScreen from "@/components/resources/CreateResourceScreen"; // Import the new screen

const queryClient = new QueryClient();

const ProtectedRoute = ({ children }: { children: React.ReactNode }) => {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) {
    // You can render a global loading spinner/page here
    return <div className="flex items-center justify-center min-h-screen">Loading Session...</div>;
  }

  return isAuthenticated ? <>{children}</> : <Navigate to="/" replace />; // Redirect to Index (StartingScreen)
};

const AppRoutes = () => {
  return (
    <Routes>
      <Route path="/" element={<Index />} />
      <Route path="/login/student" element={<LoginScreen />} />
      {/* <Route path="/login/admin" element={<LoginScreen type="admin" />} />  // Assuming one LoginScreen for now */}
      <Route path="/register" element={<div className="min-h-screen flex items-center justify-center">Registration coming soon!</div>} />

      {/* Protected Routes */}
      <Route path="/dashboard" element={<ProtectedRoute><Dashboard /></ProtectedRoute>} />
      <Route path="/results" element={<ProtectedRoute><ResultsScreen /></ProtectedRoute>} />
      <Route path="/communities" element={<ProtectedRoute><CommunitiesScreen /></ProtectedRoute>} />
      <Route path="/communities/:communityId" element={<ProtectedRoute><CommunityDetailScreen /></ProtectedRoute>} />
      <Route path="/attendance" element={<ProtectedRoute><AttendanceScreen /></ProtectedRoute>} />
      <Route path="/resources" element={<ProtectedRoute><ResourcesScreen /></ProtectedRoute>} />
      <Route path="/resources/new" element={<ProtectedRoute><CreateResourceScreen /></ProtectedRoute>} /> {/* Route for creating resource */}
      <Route path="/settings" element={<ProtectedRoute><SettingsScreen /></ProtectedRoute>} />

      <Route path="*" element={<NotFound />} />
    </Routes>
  );
};

const App = () => (
  <QueryClientProvider client={queryClient}>
    <ThemeProvider defaultTheme="light" storageKey="vite-ui-theme">
      <TooltipProvider>
        <Toaster />
        <Sonner />
        <AppRoutes />
      </TooltipProvider>
    </ThemeProvider>
  </QueryClientProvider>
);

export default App;
--- END OF CORE FILE: src/App.tsx ---

--------------------------------------------------------------

