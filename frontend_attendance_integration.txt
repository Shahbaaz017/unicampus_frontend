Frontend files for Attendance API integration - Collected on Mon Jun  2 11:15:02 UTC 2025
======================================================================

--- START OF FILE: src/components/attendance/AttendanceScreen.tsx ---

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { BarChart, Bar, XAxis, YAxis, ResponsiveContainer, Cell } from 'recharts';
import BottomNavigation from '@/components/layout/BottomNavigation';
import { useTheme } from '@/contexts/ThemeContext';

const AttendanceScreen = () => {
  const { theme } = useTheme();

  // Sample attendance data
  const attendanceData = [
    { subject: '22AL61', code: 'AIML', percentage: 85, attended: 34, total: 40 },
    { subject: '22CS62', code: 'CN', percentage: 92, attended: 46, total: 50 },
    { subject: '22CS63', code: 'DBMS', percentage: 78, attended: 39, total: 50 },
    { subject: '22CS64', code: 'SE', percentage: 88, attended: 44, total: 50 },
    { subject: '22CS65', code: 'OS', percentage: 76, attended: 38, total: 50 },
    { subject: '22IM66', code: 'IM', percentage: 95, attended: 38, total: 40 }
  ];

  const overallAttendance = Math.round(
    attendanceData.reduce((sum, subject) => sum + subject.percentage, 0) / attendanceData.length
  );

  const getBarColor = (percentage: number) => {
    if (percentage >= 75) return '#10B981'; // Green
    if (percentage >= 50) return '#F59E0B'; // Yellow
    return '#EF4444'; // Red
  };

  const CustomLabel = (props: any) => {
    const { x, y, width, value } = props;
    return (
      <text
        x={x + width / 2}
        y={y - 5}
        fill={theme === 'dark' ? '#E5E7EB' : '#374151'}
        textAnchor="middle"
        fontSize="12"
        fontWeight="500"
      >
        {value}%
      </text>
    );
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 pb-20">
      {/* Header */}
      <div className="bg-white dark:bg-gray-800 shadow-sm px-4 py-6">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Attendance</h1>
      </div>

      <div className="p-4 space-y-6">
        {/* Overall Attendance */}
        <Card className="animate-fade-in">
          <CardContent className="p-6 text-center">
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">
              Overall Attendance
            </h2>
            <div className="text-4xl font-bold text-unicampus-red mb-2">
              {overallAttendance}%
            </div>
            <p className="text-sm text-gray-600 dark:text-gray-400">
              Keep up the good work!
            </p>
          </CardContent>
        </Card>

        {/* Attendance Histogram */}
        <Card className="animate-fade-in" style={{ animationDelay: '0.1s' }}>
          <CardHeader>
            <CardTitle className="text-gray-900 dark:text-white">Subject-wise Attendance</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="h-64 w-full">
              <ResponsiveContainer width="100%" height="100%">
                <BarChart data={attendanceData} margin={{ top: 20, right: 20, left: 0, bottom: 5 }}>
                  <XAxis 
                    dataKey="code" 
                    tick={{ fontSize: 12, fill: theme === 'dark' ? '#9CA3AF' : '#6B7280' }}
                    tickLine={{ stroke: theme === 'dark' ? '#374151' : '#D1D5DB' }}
                  />
                  <YAxis 
                    domain={[0, 100]}
                    tick={{ fontSize: 12, fill: theme === 'dark' ? '#9CA3AF' : '#6B7280' }}
                    tickLine={{ stroke: theme === 'dark' ? '#374151' : '#D1D5DB' }}
                    axisLine={{ stroke: theme === 'dark' ? '#374151' : '#D1D5DB' }}
                  />
                  <Bar dataKey="percentage" radius={[4, 4, 0, 0]} label={<CustomLabel />}>
                    {attendanceData.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={getBarColor(entry.percentage)} />
                    ))}
                  </Bar>
                </BarChart>
              </ResponsiveContainer>
            </div>
          </CardContent>
        </Card>

        {/* Subject List */}
        <div className="space-y-3">
          <h2 className="text-xl font-bold text-gray-900 dark:text-white">Subjects</h2>
          {attendanceData.map((subject, index) => (
            <Card 
              key={subject.subject} 
              className="animate-slide-up cursor-pointer hover:shadow-lg transition-all"
              style={{ animationDelay: `${(index + 2) * 0.1}s` }}
            >
              <CardContent className="p-4">
                <div className="flex items-center justify-between">
                  <div className="flex-1">
                    <h3 className="font-semibold text-gray-900 dark:text-white">
                      {subject.subject} - {subject.code}
                    </h3>
                    <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                      {subject.attended}/{subject.total} classes attended
                    </p>
                  </div>
                  <div className="text-right">
                    <div 
                      className={`text-2xl font-bold ${
                        subject.percentage >= 75 
                          ? 'text-green-500' 
                          : subject.percentage >= 50 
                          ? 'text-yellow-500' 
                          : 'text-red-500'
                      }`}
                    >
                      {subject.percentage}%
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      </div>

      <BottomNavigation />
    </div>
  );
};

export default AttendanceScreen;

--- END OF FILE: src/components/attendance/AttendanceScreen.tsx ---

--------------------------------------------------------------

--- START OF CORE FILE: src/contexts/AuthContext.tsx ---
// src/contexts/AuthContext.tsx
import React, { createContext, useContext, useState, ReactNode, useEffect } from 'react';
import apiClient from '../lib/apiClient'; // Import the API client

// Updated User interface based on your /auth/login/student response
interface User {
  id: string;         // User's MongoDB ObjectId
  usn: string;
  name: string;
  email: string;       // e.g., usn@unicampus.app
  role: 'student' | 'admin'; // Assuming admin role also exists
  collegeProfile?: {
    officialName?: string;
    department?: string;
    semester?: number;
    section?: string;
    usn?: string; // Can be redundant but might be from a different source
    // Add other fields as per your API
  };
  mostRecentCGPA?: number | null;
  avatar?: string | null;
  // Add fields from /users/me if different/more comprehensive
  academicSummaries?: Array<{ code: string; name: string; cieTotal: number | null; attendancePercentage: number | null }>;
  examHistory?: Array<{ semesterName: string; creditsRegistered: number; creditsEarned: number; sgpa: number | null; cgpa: number | null }>;
  collegeDataLastUpdated?: string; // ISO datetime
  createdAt?: string; // ISO datetime
  updatedAt?: string; // ISO datetime
}

// API Response structure for login
interface LoginApiResponse {
  status: string;
  accessToken: string;
  refreshToken: string;
  data: {
    user: User;
  };
}

// API Response structure for /users/me
interface UserProfileApiResponse {
    status: string;
    data: {
        user: User;
    };
}

// API Response for token refresh
interface RefreshTokenApiResponse {
    status: string;
    accessToken: string;
}


interface AuthContextType {
  user: User | null;
  accessToken: string | null; // Store accessToken
  isLoading: boolean; // For initial load and login/logout processes
  isAuthenticated: boolean;
  login: (usn: string, dob_dd: string, dob_mm: string, dob_yyyy: string) => Promise<void>; // Update params
  logout: () => Promise<void>;
  fetchUserProfile: () => Promise<void>; // To load user on app start or refresh
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [accessToken, setAccessToken] = useState<string | null>(localStorage.getItem('accessToken'));
  const [refreshToken, setRefreshToken] = useState<string | null>(localStorage.getItem('refreshToken'));
  const [isLoading, setIsLoading] = useState(true); // True initially to load user

  const isAuthenticated = !!accessToken && !!user; // User must also be loaded

  useEffect(() => {
    const loadUserFromToken = async () => {
      if (accessToken) {
        try {
          await fetchUserProfile(); // Try to fetch user profile if token exists
        } catch (error: any) {
          console.error("Failed to load user with existing token:", error);
          if (error.httpStatus === 401) { // If token is invalid/expired
            await attemptRefreshTokenAndRetry(fetchUserProfile);
          } else {
            // For other errors, or if refresh fails, clear auth data
            clearAuthData();
          }
        }
      }
      setIsLoading(false);
    };
    loadUserFromToken();
  }, []); // Empty dependency array: run once on mount

  const storeAuthData = (accessTok: string, refreshTok: string, userData?: User) => {
    localStorage.setItem('accessToken', accessTok);
    localStorage.setItem('refreshToken', refreshTok);
    setAccessToken(accessTok);
    setRefreshToken(refreshTok);
    if (userData) {
        setUser(userData);
    }
  };

  const clearAuthData = () => {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
    setAccessToken(null);
    setRefreshToken(null);
    setUser(null);
  };

  const login = async (usn: string, dob_dd: string, dob_mm: string, dob_yyyy: string): Promise<void> => {
    setIsLoading(true);
    try {
      const response = await apiClient<LoginApiResponse>('/auth/login/student', {
        method: 'POST',
        data: { usn, dob_dd, dob_mm, dob_yyyy }, // Match your API request body
        isPublic: true, // Login doesn't require a token
      });

      if (response.status === 'success' && response.accessToken && response.refreshToken && response.data.user) {
        storeAuthData(response.accessToken, response.refreshToken, response.data.user);
      } else {
        // If API returns success but missing data, treat as error
        throw new Error(response.status || 'Login failed: Invalid response from server.');
      }
    } catch (error: any) {
      clearAuthData(); // Ensure tokens are cleared on login failure
      console.error("Login error:", error);
      throw error; // Re-throw to be caught by LoginScreen
    } finally {
      setIsLoading(false);
    }
  };

  const logout = async () => {
    setIsLoading(true);
    // Call backend logout if it exists and does something meaningful (e.g., invalidates refresh token)
    try {
        if (accessToken) { // Only call if there's a token to invalidate
            await apiClient('/auth/logout', { method: 'POST' });
        }
    } catch (error) {
        console.warn("Backend logout call failed or not critical, clearing client-side tokens:", error);
    } finally {
        clearAuthData();
        setIsLoading(false);
        // Optionally navigate to login or home page after logout
        // navigate('/login'); // if using react-router
    }
  };

  const fetchUserProfile = async (): Promise<void> => {
    if (!localStorage.getItem('accessToken')) { // Use localStorage directly here as state might not be updated yet
      // setIsLoading(false); // Ensure loading state is managed
      return; // No token, no user to fetch
    }
    // setIsLoading(true); // Set loading true when fetching
    try {
      const response = await apiClient<UserProfileApiResponse>('/users/me', { method: 'GET' });
      if (response.status === 'success' && response.data.user) {
        setUser(response.data.user);
      } else {
        throw new Error('Failed to fetch user profile: Invalid response.');
      }
    } catch (error: any) {
      console.error("Fetch user profile error:", error);
      if (error.httpStatus === 401) { // Token might be expired
        // Attempt to refresh token, then retry fetching profile
        await attemptRefreshTokenAndRetry(fetchUserProfile);
      } else {
        // For other errors, or if refresh fails, clear auth data
        clearAuthData();
      }
      throw error; // Re-throw for components or initial load to handle
    }
    // finally { setIsLoading(false); } // Manage loading state appropriately
  };

  const attemptRefreshTokenAndRetry = async (retryCallback: () => Promise<void>) => {
    const currentRefreshToken = localStorage.getItem('refreshToken');
    if (!currentRefreshToken) {
      console.log("No refresh token available. Logging out.");
      clearAuthData();
      return;
    }

    try {
      console.log("Attempting to refresh token...");
      const refreshResponse = await apiClient<RefreshTokenApiResponse>('/auth/refresh-token', {
        method: 'POST',
        isRefreshTokenRequest: true, // Use refresh token for Authorization header
        isPublic: false, // Although it uses a token, it's a specific auth flow
      });

      if (refreshResponse.status === 'success' && refreshResponse.accessToken) {
        console.log("Token refreshed successfully.");
        // Store only the new access token. Refresh token might also be rotated by backend.
        // For simplicity, we assume refresh token remains valid or backend doesn't rotate it often.
        // If backend sends new refresh token, update it here.
        storeAuthData(refreshResponse.accessToken, currentRefreshToken); // Re-use old refresh token for now
        await retryCallback(); // Retry the original failed request (e.g., fetchUserProfile)
      } else {
        console.error("Token refresh failed with success status but no new token.");
        clearAuthData(); // If refresh fails, logout
      }
    } catch (refreshError) {
      console.error("Token refresh API call failed:", refreshError);
      clearAuthData(); // If refresh fails, logout
    }
  };


  return (
    <AuthContext.Provider value={{
      user,
      accessToken, // Expose accessToken if needed by other parts of app directly (though apiClient handles it)
      isLoading,
      login,
      logout,
      isAuthenticated,
      fetchUserProfile
    }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
--- END OF CORE FILE: src/contexts/AuthContext.tsx ---

--------------------------------------------------------------

--- START OF CORE FILE: src/lib/apiClient.ts ---
// src/lib/apiClient.ts
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001/api/v1';

// Helper to get token from localStorage (AuthContext will manage this)
const getAuthToken = (): string | null => {
  return localStorage.getItem('accessToken');
};

interface ApiClientOptions extends RequestInit {
  data?: any;
  isPublic?: boolean; // To bypass auth header for public routes
  isRefreshTokenRequest?: boolean; // Special flag for refresh token request
}

// Define a generic error structure your API might return
interface ApiError {
  status: string; // "fail" or "error"
  message: string;
  // Add other potential error fields
}

export interface PaginatedResponse<T> {
  status: string;
  results?: number; // If your API returns total results
  data: T[]; // Assuming data is always an array for paginated lists
  // Add other pagination fields if your API returns them (e.g., totalPages, currentPage)
}


async function apiClient<T>(
  endpoint: string,
  { data, headers: customHeaders, isPublic = false, isRefreshTokenRequest = false, ...customConfig }: ApiClientOptions = {}
): Promise<T> {
  const config: RequestInit = {
    method: data ? 'POST' : 'GET', // Default to POST if data is provided
    ...customConfig,
    headers: {
      ...(data && !(data instanceof FormData) && { 'Content-Type': 'application/json' }), // Don't set for FormData
      ...customHeaders,
    },
  };

  if (!isPublic) {
    const token = isRefreshTokenRequest ? localStorage.getItem('refreshToken') : getAuthToken();
    if (token) {
      config.headers = {
        ...config.headers,
        Authorization: `Bearer ${token}`,
      };
    } else if (endpoint !== '/auth/login/student' && !endpoint.startsWith('/app/info')) {
      // For non-public routes (excluding login and app info), if no token, it's an issue.
      // AuthContext will handle redirect or state change.
      console.warn(`No auth token found for protected route: ${endpoint}`);
      // Throw an error or let AuthContext handle this by checking isAuthenticated
      return Promise.reject({ status: 401, message: 'Authentication token is missing.' });
    }
  }

  if (data) {
    if (data instanceof FormData) {
      config.body = data; // FormData handles its own content type
    } else {
      config.body = JSON.stringify(data);
    }
  }

  const response = await fetch(`${API_BASE_URL}${endpoint}`, config);

  if (!response.ok) {
    // Attempt to parse error JSON, otherwise use statusText
    let errorData: ApiError | { message: string };
    try {
      errorData = await response.json();
      if (typeof errorData !== 'object' || !('message' in errorData)) {
        // If the parsed JSON doesn't have a message, create one
        errorData = { message: response.statusText || 'Unknown error occurred' };
      }
    } catch (e) {
      errorData = { message: response.statusText || 'Failed to parse error response.' };
    }
    // Add status code to the rejected error object
    return Promise.reject({ httpStatus: response.status, ...errorData });
  }

  if (response.status === 204 || response.headers.get('Content-Length') === '0') {
    // For 204 No Content or empty responses, resolve with a success indicator or undefined.
    // Depending on T, you might want to cast or return a specific success object.
    return { status: 'success', message: 'Operation successful' } as unknown as T;
  }

  return response.json() as Promise<T>;
}

export default apiClient;
--- END OF CORE FILE: src/lib/apiClient.ts ---

--------------------------------------------------------------

